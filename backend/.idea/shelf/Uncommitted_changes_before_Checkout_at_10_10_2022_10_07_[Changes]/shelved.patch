Index: main.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2022. Rasmus Mäki\r\n */\r\n\r\npackage main\r\n\r\nimport (\r\n\t\"backend/restaurants\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/gin-contrib/cors\"\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"golang.org/x/exp/slices\"\r\n)\r\n\r\nvar allPossibleCities = []string{\r\n\t\"helsinki\",\r\n\t\"espoo\",\r\n\t\"vantaa\",\r\n\t\"nurmijärvi\",\r\n\t\"kerava\",\r\n\t\"järvenpää\",\r\n\t\"vihti\",\r\n\t\"porvoo\",\r\n\t\"lohja\",\r\n\t\"hyvinkää\",\r\n\t\"karkkila\",\r\n\t\"riihimäki\",\r\n\t\"tallinna\",\r\n\t\"hämeenlinna\",\r\n\t\"lahti\",\r\n\t\"forssa\",\r\n\t\"salo\",\r\n\t\"kotka\",\r\n\t\"kouvola\",\r\n\t\"akaa\",\r\n\t\"loimaa\",\r\n\t\"heinola\",\r\n\t\"hamina\",\r\n\t\"kaarina\",\r\n\t\"turku\",\r\n\t\"kangasala\",\r\n\t\"raisio\",\r\n\t\"tampere\",\r\n\t\"nokia\",\r\n\t\"luumäki\",\r\n\t\"laitila\",\r\n\t\"lappeenranta\",\r\n\t\"mikkeli\",\r\n\t\"rauma\",\r\n\t\"ulvila\",\r\n\t\"pori\",\r\n\t\"jyväskylä\",\r\n\t\"imatra\",\r\n\t\"pieksämäki\",\r\n\t\"savonlinna\",\r\n\t\"varkaus\",\r\n\t\"seinäjoki\",\r\n\t\"kuopio\",\r\n\t\"joensuu\",\r\n\t\"kitee\",\r\n\t\"vaasa\",\r\n\t\"iisalmi\",\r\n\t\"lieksa\",\r\n\t\"kokkola\",\r\n\t\"ylivieska\",\r\n\t\"nurmes\",\r\n\t\"kajaani\",\r\n\t\"sotkamo\",\r\n\t\"muhos\",\r\n\t\"kempele\",\r\n\t\"oulu\",\r\n\t\"rovaniemi\",\r\n\t\"kittilä\"}\r\n\r\n/*\r\n* Stuff to fix:\r\nGET http://localhost:10000/raflaamo/tables/tampere/1\r\n- TODO: some tableReservationLocalized fields are empty for some reason.\r\n- TODO: some available_time_slots are null for some reason, if they're null they should not even be included.\r\n*/\r\n\r\ntype Endpoint struct {\r\n\tc              *gin.Context\r\n\tcors           cors.Config\r\n\tuserParameters *UserParameters\r\n}\r\n\r\ntype UserParameters struct {\r\n\tcity           string\r\n\tamountOfEaters string\r\n}\r\n\r\nfunc (endpoint *Endpoint) getUserRaflaamoParameters() *UserParameters {\r\n\treturn &UserParameters{\r\n\t\tcity:           endpoint.c.Param(\"city\"),\r\n\t\tamountOfEaters: endpoint.c.Param(\"amountOfEaters\"),\r\n\t}\r\n}\r\n\r\n/*\r\n* Contract for userInputIsInvalid:\r\n* endpoint.userParameters has to be populated.\r\n */\r\n\r\n// TODO: add a struct and methods inside of it for endpoint related stuff.\r\nfunc (endpoint *Endpoint) userInputIsInvalid() bool {\r\n\tusersAmountOfEaters := endpoint.userParameters.amountOfEaters\r\n\tusersCityToCheck := endpoint.userParameters.city\r\n\r\n\tif usersAmountOfEaters == \"\" || usersCityToCheck == \"\" {\r\n\t\treturn true\r\n\t}\r\n\r\n\tif endpoint.usersAmountOfEatersIsNotNumber() {\r\n\t\treturn true\r\n\t}\r\n\r\n\tif endpoint.raflaamoDoesNotContainCity() {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (endpoint *Endpoint) raflaamoDoesNotContainCity() bool {\r\n\treturn !slices.Contains(allPossibleCities, strings.ToLower(endpoint.userParameters.city))\r\n}\r\n\r\nfunc (endpoint *Endpoint) usersAmountOfEatersIsNotNumber() bool {\r\n\tif _, err := strconv.Atoi(endpoint.userParameters.amountOfEaters); err != nil {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc main() {\r\n\tr := gin.Default()\r\n\tconfig := cors.DefaultConfig()\r\n\tconfig.AllowOrigins = []string{\"https://raflaamo.rasmusmaki.com\"}\r\n\tr.GET(\"/raflaamo/tables/:city/:amountOfEaters\", func(c *gin.Context) {\r\n\t\tendpoint := &Endpoint{\r\n\t\t\tc:    c,\r\n\t\t\tcors: config,\r\n\t\t}\r\n\t\tendpoint.userParameters = endpoint.getUserRaflaamoParameters()\r\n\r\n\t\tif endpoint.userInputIsInvalid() {\r\n\t\t\tc.JSON(http.StatusBadRequest, \"no results found with that city\")\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tcollectedRestaurants := restaurants.GetRestaurantsAndCollectResults(endpoint.userParameters.city, endpoint.userParameters.amountOfEaters)\r\n\t\tc.JSON(http.StatusOK, collectedRestaurants)\r\n\t})\r\n\tlog.Fatalln(r.Run(\":10000\"))\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.go b/main.go
--- a/main.go	(revision 30c1ba73302c9f79fd18eb7ed5fb2a1ffecb43de)
+++ b/main.go	(date 1665384496276)
@@ -105,8 +105,6 @@
 * Contract for userInputIsInvalid:
 * endpoint.userParameters has to be populated.
  */
-
-// TODO: add a struct and methods inside of it for endpoint related stuff.
 func (endpoint *Endpoint) userInputIsInvalid() bool {
 	usersAmountOfEaters := endpoint.userParameters.amountOfEaters
 	usersCityToCheck := endpoint.userParameters.city
Index: restaurants/getRestaurantsAndAvailableTables.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2022. Rasmus Mäki\r\n */\r\n\r\npackage restaurants\r\n\r\nimport (\r\n\t\"backend/raflaamoGraphApi\"\r\n\t\"backend/raflaamoRestaurantsApi\"\r\n\t\"backend/raflaamoTime\"\r\n\t\"log\"\r\n\t\"sync\"\r\n)\r\n\r\nfunc getRestaurants(city string, amountOfEaters string) *Restaurants {\r\n\tallNeededRaflaamoTimes := raflaamoTime.GetAllNeededRaflaamoTimes(RegexToMatchTime, RegexToMatchDate)\r\n\tgraphApi := raflaamoGraphApi.GetRaflaamoGraphApi()\r\n\tinitializedRaflaamoRestaurantsApi := raflaamoRestaurantsApi.GetRaflaamoRestaurantsApi(city)\r\n\treturn &Restaurants{\r\n\t\tCity:                   city,\r\n\t\tAmountOfEaters:         amountOfEaters,\r\n\t\tAllNeededRaflaamoTimes: allNeededRaflaamoTimes,\r\n\t\tGraphApi:               graphApi,\r\n\t\tRestaurantsApi:         initializedRaflaamoRestaurantsApi,\r\n\t}\r\n}\r\n\r\n// GetRestaurantsAndAvailableTables This is the entry point to the functionality.\r\nfunc (restaurants *Restaurants) getRestaurantsAndAvailableTables() []raflaamoRestaurantsApi.ResponseFields {\r\n\tcurrentTime := restaurants.AllNeededRaflaamoTimes.TimeAndDate.CurrentTime\r\n\tallRestaurantsFromRaflaamoRestaurantsApi, err := restaurants.RestaurantsApi.GetAllRestaurantsFromRaflaamoRestaurantsApi(currentTime)\r\n\tif err != nil {\r\n\t\tlog.Fatalln(err)\r\n\t}\r\n\r\n\tfor index := range allRestaurantsFromRaflaamoRestaurantsApi {\r\n\t\trestaurant := &allRestaurantsFromRaflaamoRestaurantsApi[index]\r\n\t\tgo restaurants.getAvailableTablesForRestaurant(restaurant)\r\n\t}\r\n\treturn allRestaurantsFromRaflaamoRestaurantsApi\r\n}\r\n\r\nfunc (restaurants *Restaurants) getAvailableTablesForRestaurant(restaurant *raflaamoRestaurantsApi.ResponseFields) {\r\n\trestaurantsKitchenClosingTime := restaurant.Openingtime.Kitchentime.Ranges[0].End\r\n\trestaurants.AllNeededRaflaamoTimes.GetAllGraphApiUnixTimeIntervalsFromCurrentPointForward(restaurantsKitchenClosingTime)\r\n\r\n\traflaamoGraphApiRequestUrlStruct := raflaamoGraphApi.GetRaflaamoGraphApiRequestUrl(restaurant.Links.TableReservationLocalized.FiFi, restaurants.AmountOfEaters, restaurants.AllNeededRaflaamoTimes.TimeAndDate.CurrentDate, regexToMatchRestaurantId)\r\n\trestaurant.Links.TableReservationLocalizedId = raflaamoGraphApiRequestUrlStruct.IdFromReservationPageUrl // Storing the id for the front end.\r\n\r\n\trestaurantGraphApiRequestUrls := raflaamoGraphApiRequestUrlStruct.GenerateGraphApiRequestUrlsForRestaurant(restaurants.AllNeededRaflaamoTimes)\r\n\r\n\trestaurants.addRelativeTimesToRestaurant(restaurant, restaurantsKitchenClosingTime)\r\n\r\n\trestaurants.getAvailableTableTimesFromRestaurantRequestUrlsIntoRestaurantsChannel(restaurant, restaurantGraphApiRequestUrls)\r\n}\r\n\r\nfunc (restaurants *Restaurants) addRelativeTimesToRestaurant(restaurant *raflaamoRestaurantsApi.ResponseFields, restaurantsKitchenClosingTime string) {\r\n\tcurrentTime := restaurants.AllNeededRaflaamoTimes.TimeAndDate.CurrentTime\r\n\r\n\tcalculateTimeTillKitchenCloses := raflaamoTime.GetCalculateClosingTime(currentTime, restaurantsKitchenClosingTime)\r\n\trestaurants.addRelativeKitchenTime(restaurant, calculateTimeTillKitchenCloses, currentTime)\r\n\r\n\tcalculateTimeTillRestaurantCloses := raflaamoTime.GetCalculateClosingTime(currentTime, restaurant.Openingtime.Restauranttime.Ranges[0].End)\r\n\trestaurants.addRelativeRestaurantTime(restaurant, calculateTimeTillRestaurantCloses, currentTime)\r\n}\r\n\r\n/* Contract:\r\n*  currentTime should not be bigger than restaurantClosingTime.\r\n*  This contract is currently enforced in [restaurantsApi.go] (filterBadRestaurantsOut).\r\n */\r\nfunc (restaurants *Restaurants) addRelativeRestaurantTime(restaurant *raflaamoRestaurantsApi.ResponseFields, calculateRestaurantsClosingTime *raflaamoTime.CalculateClosingTime, currentTime int64) {\r\n\trestaurantRelativeTime := calculateRestaurantsClosingTime.CalculateRelativeTime()\r\n\trestaurant.Openingtime.TimeTillRestaurantClosedMinutes = restaurantRelativeTime.RelativeMinutes\r\n\trestaurant.Openingtime.TimeTillRestaurantClosedHours = restaurantRelativeTime.RelativeHours\r\n}\r\n\r\n/* Contract:\r\n*  currentTime should not be bigger than restaurantsKitchenClosingTime.\r\n*  This contract is currently enforced in [restaurantsApi.go] (filterBadRestaurantsOut).\r\n */\r\nfunc (restaurants *Restaurants) addRelativeKitchenTime(restaurant *raflaamoRestaurantsApi.ResponseFields, calculateKitchenClosingTime *raflaamoTime.CalculateClosingTime, currentTime int64) {\r\n\t//calculateTimeTillKitchenCloses := raflaamoTime.GetCalculateClosingTime(currentTime, restaurantsKitchenClosingTime)\r\n\tkitchenRelativeTime := calculateKitchenClosingTime.CalculateRelativeTime()\r\n\trestaurant.Openingtime.TimeLeftToReserveMinutes = kitchenRelativeTime.RelativeMinutes\r\n\trestaurant.Openingtime.TimeLeftToReserveHours = kitchenRelativeTime.RelativeHours\r\n}\r\n\r\nfunc (restaurants *Restaurants) getAvailableTableTimesFromRestaurantRequestUrlsIntoRestaurantsChannel(restaurant *raflaamoRestaurantsApi.ResponseFields, restaurantGraphApiRequestUrls []string) {\r\n\tvar wg sync.WaitGroup\r\n\tfor _, restaurantGraphApiRequestUrl := range restaurantGraphApiRequestUrls {\r\n\t\trestaurantGraphApiRequestUrl := restaurantGraphApiRequestUrl\r\n\t\twg.Add(1)\r\n\t\tgo func() {\r\n\t\t\tdefer wg.Done()\r\n\t\t\tgraphApiResponseFromRequestUrl, err := restaurants.GraphApi.GetGraphApiResponseFromTimeSlot(restaurantGraphApiRequestUrl)\r\n\r\n\t\t\tif err != nil {\r\n\t\t\t\t// TODO: handle if this is an error just because some time slot wasn't visible (transparent).\r\n\t\t\t\trestaurant.GraphApiResults.Err <- err\r\n\t\t\t\trestaurant.GraphApiResults.AvailableTimeSlotsBuffer <- \"\"\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\ttimeIntervals := *graphApiResponseFromRequestUrl.Intervals\r\n\t\t\tif timeIntervals[0].Color == \"transparent\" {\r\n\t\t\t\t// TODO: handle it somehow, we are forced to send something in to the channel.\r\n\t\t\t\trestaurant.GraphApiResults.AvailableTimeSlotsBuffer <- \"\"\r\n\t\t\t\trestaurant.GraphApiResults.Err <- nil\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tgraphApiReservationTimes := raflaamoTime.GetGraphApiReservationTimes(graphApiResponseFromRequestUrl)\r\n\r\n\t\t\tgraphApiReservationTimes.GetTimeSlotsInBetweenUnixIntervals(restaurant, restaurants.AllNeededRaflaamoTimes.AllFutureRaflaamoReservationTimeIntervals)\r\n\t\t}()\r\n\t}\r\n\twg.Wait()\r\n\tclose(restaurant.GraphApiResults.Err)\r\n\tclose(restaurant.GraphApiResults.AvailableTimeSlotsBuffer)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/restaurants/getRestaurantsAndAvailableTables.go b/restaurants/getRestaurantsAndAvailableTables.go
--- a/restaurants/getRestaurantsAndAvailableTables.go	(revision 30c1ba73302c9f79fd18eb7ed5fb2a1ffecb43de)
+++ b/restaurants/getRestaurantsAndAvailableTables.go	(date 1665385196088)
@@ -93,7 +93,6 @@
 		go func() {
 			defer wg.Done()
 			graphApiResponseFromRequestUrl, err := restaurants.GraphApi.GetGraphApiResponseFromTimeSlot(restaurantGraphApiRequestUrl)
-
 			if err != nil {
 				// TODO: handle if this is an error just because some time slot wasn't visible (transparent).
 				restaurant.GraphApiResults.Err <- err
@@ -103,18 +102,17 @@
 
 			timeIntervals := *graphApiResponseFromRequestUrl.Intervals
 			if timeIntervals[0].Color == "transparent" {
-				// TODO: handle it somehow, we are forced to send something in to the channel.
+				// we are forced to send something in to the channel.
 				restaurant.GraphApiResults.AvailableTimeSlotsBuffer <- ""
 				restaurant.GraphApiResults.Err <- nil
 				return
 			}
-
 			graphApiReservationTimes := raflaamoTime.GetGraphApiReservationTimes(graphApiResponseFromRequestUrl)
 
 			graphApiReservationTimes.GetTimeSlotsInBetweenUnixIntervals(restaurant, restaurants.AllNeededRaflaamoTimes.AllFutureRaflaamoReservationTimeIntervals)
 		}()
 	}
 	wg.Wait()
-	close(restaurant.GraphApiResults.Err)
 	close(restaurant.GraphApiResults.AvailableTimeSlotsBuffer)
+	close(restaurant.GraphApiResults.Err)
 }
Index: raflaamoTime/ralfaamoReservingTimes.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2022. Rasmus Mäki\r\n */\r\n\r\npackage raflaamoTime\r\n\r\nimport (\r\n\t\"backend/graphApiResponseStructure\"\r\n\t\"backend/raflaamoRestaurantsApi\"\r\n\t\"backend/unixHelpers\"\r\n)\r\n\r\ntype GraphApiReservationTimes struct {\r\n\tgraphApiIntervalStart       int64\r\n\tgraphApiIntervalStartString string\r\n\tgraphApiIntervalEnd         int64\r\n\tgraphApiIntervalEndString   string\r\n}\r\n\r\nfunc GetGraphApiReservationTimes(graphApiResponse *graphApiResponseStructure.ParsedGraphData) *GraphApiReservationTimes {\r\n\tgraphApiResponseTimeIntervals := *graphApiResponse.Intervals\r\n\r\n\tgraphApiTimeIntervalStart := graphApiResponseTimeIntervals[0].From\r\n\tgraphApiTimeIntervalEnd := graphApiResponseTimeIntervals[0].To\r\n\r\n\tgraphApiReservationTimes := GraphApiReservationTimes{graphApiIntervalStart: graphApiTimeIntervalStart, graphApiIntervalEnd: graphApiTimeIntervalEnd}\r\n\r\n\tconvertReservationTimesIntoDesiredFormat(&graphApiReservationTimes)\r\n\r\n\treturn &graphApiReservationTimes\r\n}\r\n\r\nfunc convertReservationTimesIntoDesiredFormat(graphApiReservationTimes *GraphApiReservationTimes) {\r\n\tgraphApiReservationTimes.convertStartUnixIntervalIntoString(true)\r\n\tgraphApiReservationTimes.convertEndUnixIntervalIntoString(true)\r\n\r\n\tgraphApiReservationTimes.graphApiIntervalStart = graphApiReservationTimes.convertStartUnixIntervalBackIntoDesiredUnixFormat()\r\n\tgraphApiReservationTimes.graphApiIntervalEnd = graphApiReservationTimes.convertEndUnixIntervalBackIntoDesiredUnixFormat()\r\n}\r\n\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) GetTimeSlotsInBetweenUnixIntervals(restaurant *raflaamoRestaurantsApi.ResponseFields, allRaflaamoReservationUnixTimeIntervals []int64) {\r\n\tlastPossibleReservationTime := graphApiReservationTimes.getLastPossibleReservationTime(restaurant)\r\n\tfor _, raflaamoReservationUnixTimeInterval := range allRaflaamoReservationUnixTimeIntervals {\r\n\t\tif graphApiReservationTimes.reservationUnixTimeIntervalIsValid(raflaamoReservationUnixTimeInterval, lastPossibleReservationTime) {\r\n\t\t\traflaamoReservationTime := unixHelpers.ConvertUnixSecondsToString(raflaamoReservationUnixTimeInterval, false)\r\n\t\t\trestaurant.GraphApiResults.AvailableTimeSlotsBuffer <- raflaamoReservationTime\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) reservationUnixTimeIntervalIsValid(raflaamoReservationUnixTimeInterval int64, lastPossibleReservationTime int64) bool {\r\n\tif raflaamoReservationUnixTimeInterval > graphApiReservationTimes.graphApiIntervalStart && raflaamoReservationUnixTimeInterval <= lastPossibleReservationTime {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) getLastPossibleReservationTime(restaurant *raflaamoRestaurantsApi.ResponseFields) int64 {\r\n\tconst oneHour = 3600 // Restaurants don't take reservations one hour before closing.\r\n\trestaurantsKitchenClosingTimeUnix := unixHelpers.ConvertStringTimeToDesiredUnixFormat(restaurant.Openingtime.Kitchentime.Ranges[0].End)\r\n\tlastPossibleReservationTime := restaurantsKitchenClosingTimeUnix - oneHour\r\n\treturn lastPossibleReservationTime\r\n}\r\n\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) convertStartUnixIntervalIntoString(convertToFinnishTime bool) {\r\n\tif convertToFinnishTime {\r\n\t\tgraphApiReservationTimes.graphApiIntervalStart += 3600000 * 3 // Adding three hours into the time to match finnish timezone.\r\n\t}\r\n\tstartIntervalString := unixHelpers.ConvertUnixMilliSecondsToString(graphApiReservationTimes.graphApiIntervalStart)\r\n\r\n\tgraphApiReservationTimes.graphApiIntervalStartString = startIntervalString\r\n}\r\n\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) convertEndUnixIntervalIntoString(convertToFinnishTime bool) {\r\n\tif convertToFinnishTime {\r\n\t\tgraphApiReservationTimes.graphApiIntervalEnd += 3600000 * 3 // Adding three hours into the time to match finnish timezone.\r\n\t}\r\n\r\n\tendIntervalString := unixHelpers.ConvertUnixMilliSecondsToString(graphApiReservationTimes.graphApiIntervalEnd)\r\n\tgraphApiReservationTimes.graphApiIntervalEndString = endIntervalString\r\n}\r\n\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) convertStartUnixIntervalBackIntoDesiredUnixFormat() int64 {\r\n\tstartIntervalString := graphApiReservationTimes.graphApiIntervalStartString\r\n\tstartIntervalStringInDesiredUnixFormat := unixHelpers.ConvertStringTimeToDesiredUnixFormat(startIntervalString)\r\n\treturn startIntervalStringInDesiredUnixFormat\r\n}\r\n\r\nfunc (graphApiReservationTimes *GraphApiReservationTimes) convertEndUnixIntervalBackIntoDesiredUnixFormat() int64 {\r\n\tendIntervalString := graphApiReservationTimes.graphApiIntervalEndString\r\n\tendIntervalStringInDesiredUnixFormat := unixHelpers.ConvertStringTimeToDesiredUnixFormat(endIntervalString)\r\n\treturn endIntervalStringInDesiredUnixFormat\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/raflaamoTime/ralfaamoReservingTimes.go b/raflaamoTime/ralfaamoReservingTimes.go
--- a/raflaamoTime/ralfaamoReservingTimes.go	(revision 30c1ba73302c9f79fd18eb7ed5fb2a1ffecb43de)
+++ b/raflaamoTime/ralfaamoReservingTimes.go	(date 1665385193322)
@@ -40,6 +40,7 @@
 
 func (graphApiReservationTimes *GraphApiReservationTimes) GetTimeSlotsInBetweenUnixIntervals(restaurant *raflaamoRestaurantsApi.ResponseFields, allRaflaamoReservationUnixTimeIntervals []int64) {
 	lastPossibleReservationTime := graphApiReservationTimes.getLastPossibleReservationTime(restaurant)
+	restaurant.GraphApiResults.Err <- nil
 	for _, raflaamoReservationUnixTimeInterval := range allRaflaamoReservationUnixTimeIntervals {
 		if graphApiReservationTimes.reservationUnixTimeIntervalIsValid(raflaamoReservationUnixTimeInterval, lastPossibleReservationTime) {
 			raflaamoReservationTime := unixHelpers.ConvertUnixSecondsToString(raflaamoReservationUnixTimeInterval, false)
Index: restaurants/captureResults.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2022. Rasmus Mäki\r\n */\r\n\r\npackage restaurants\r\n\r\nimport (\r\n\t\"backend/raflaamoRestaurantsApi\"\r\n\r\n\t\"golang.org/x/exp/slices\"\r\n)\r\n\r\nfunc removeIndexFromSlice[T any](slice []T, s int) []T {\r\n\treturn append(slice[:s], slice[s+1:]...)\r\n}\r\n\r\nfunc GetRestaurantsAndCollectResults(city string, amountOfEaters string) []raflaamoRestaurantsApi.ResponseFields {\r\n\trestaurantsInstance := getRestaurants(city, amountOfEaters)\r\n\traflaamoRestaurants := restaurantsInstance.getRestaurantsAndAvailableTables()\r\n\tfor index := range raflaamoRestaurants {\r\n\t\trestaurant := &raflaamoRestaurants[index] // or else it's not an actual ptr.\r\n\r\n\t\ttimeSlotsForRestaurants := captureTimeSlotsForRestaurant(restaurant)\r\n\t\tif len(timeSlotsForRestaurants) == 0 { // We want to remove restaurants that don't have available time slots.\r\n\t\t\tremoveIndexFromSlice(raflaamoRestaurants, index)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\trestaurant.AvailableTimeSlots = timeSlotsForRestaurants\r\n\t}\r\n\treturn raflaamoRestaurants\r\n}\r\n\r\nfunc captureTimeSlotsForRestaurant(raflaamoRestaurant *raflaamoRestaurantsApi.ResponseFields) []string {\r\n\terr := <-raflaamoRestaurant.GraphApiResults.Err\r\n\tif err != nil {\r\n\t\treturn nil\r\n\t}\r\n\ttimeSlotsForRestaurant := iterateAndCaptureRestaurantTimeSlots(raflaamoRestaurant)\r\n\tslices.Sort(timeSlotsForRestaurant)\r\n\treturn timeSlotsForRestaurant\r\n}\r\n\r\n// iterateAndCaptureRestaurantTimeSlots captures the results from a channel because we send it over the network as JSON.\r\nfunc iterateAndCaptureRestaurantTimeSlots(restaurant *raflaamoRestaurantsApi.ResponseFields) []string {\r\n\tavailableTimeSlots := make([]string, 0, 50)\r\n\tfor availableTimeSlot := range restaurant.GraphApiResults.AvailableTimeSlotsBuffer {\r\n\t\tif GraphApiResponseHadNoTimeSlots(availableTimeSlot) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tavailableTimeSlots = append(availableTimeSlots, availableTimeSlot)\r\n\t}\r\n\treturn availableTimeSlots\r\n}\r\n\r\n// GraphApiResponseHadNoTimeSlots if graph API response had the \"transparent\" field set.\r\nfunc GraphApiResponseHadNoTimeSlots(timeSlotResult string) bool {\r\n\t// This exists because some time slots might have \"transparent\" field set aka no time slots found.\r\n\t// And we are forced to send something down the channel or else it will keep waiting forever expecting n items to iterate.\r\n\treturn timeSlotResult == \"\"\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/restaurants/captureResults.go b/restaurants/captureResults.go
--- a/restaurants/captureResults.go	(revision 30c1ba73302c9f79fd18eb7ed5fb2a1ffecb43de)
+++ b/restaurants/captureResults.go	(date 1665385490821)
@@ -21,7 +21,7 @@
 		restaurant := &raflaamoRestaurants[index] // or else it's not an actual ptr.
 
 		timeSlotsForRestaurants := captureTimeSlotsForRestaurant(restaurant)
-		if len(timeSlotsForRestaurants) == 0 { // We want to remove restaurants that don't have available time slots.
+		if len(timeSlotsForRestaurants) == 0 || timeSlotsForRestaurants == nil { // We want to remove restaurants that don't have available time slots.
 			removeIndexFromSlice(raflaamoRestaurants, index)
 			continue
 		}
Index: raflaamoRestaurantsApi/restaurantsApi.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2022. Rasmus Mäki\r\n */\r\n\r\npackage raflaamoRestaurantsApi\r\n\r\nimport (\r\n\t\"backend/unixHelpers\"\r\n\t\"bytes\"\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"strings\"\r\n)\r\n\r\nfunc GetRaflaamoRestaurantsApi(city string) *RaflaamoRestaurantsApi {\r\n\thttpClient := &http.Client{}\r\n\tconst data = `{\"operationName\":\"getRestaurantsByLocation\",\"variables\":{\"first\":1000,\"input\":{\"restaurantType\":\"ALL\",\"locationName\":\"Helsinki\",\"feature\":{\"rentableVenues\":false}},\"after\":\"eyJmIjowLCJnIjp7ImEiOjYwLjE3MTE2LCJvIjoyNC45MzI1OH19\"},\"query\":\"fragment Locales on LocalizedString {fi_FI }fragment Restaurant on Restaurant {  id  name {    ...Locales    }  address {    municipality {      ...Locales       }        street {      ...Locales       }       zipCode     }   openingTime {    restaurantTime {      ranges {        start        end             }             }    kitchenTime {      ranges {        start        end        endNextDay              }             }    }  links {    tableReservationLocalized {      ...Locales        }    homepageLocalized {      ...Locales          }   }     }query getRestaurantsByLocation($first: Int, $after: String, $input: ListRestaurantsByLocationInput!) {  listRestaurantsByLocation(first: $first, after: $after, input: $input) {    totalCount      edges {      ...Restaurant        }     }}\"}`\r\n\r\n\treq, err := http.NewRequest(\"POST\", \"https://api.raflaamo.fi/query\", bytes.NewBuffer([]byte(data)))\r\n\r\n\tif err != nil {\r\n\t\tlog.Fatalln(\"[GetRaflaamoRestaurantsApi] - err but shouldn't be\")\r\n\t}\r\n\treq.Header.Add(\"Content-Type\", \"application/json\")\r\n\treq.Header.Add(\"client_id\", \"jNAWMvWD9rp637RaR\")\r\n\treq.Header.Add(\"User-Agent\", \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\")\r\n\r\n\treturn &RaflaamoRestaurantsApi{\r\n\t\thttpClient:               httpClient,\r\n\t\trequest:                  req,\r\n\t\tcityToGetRestaurantsFrom: city,\r\n\t}\r\n}\r\n\r\nfunc (raflaamoRestaurantsApi *RaflaamoRestaurantsApi) getRestaurantsFromRaflaamoApi(currentTime int64) ([]ResponseFields, error) {\r\n\thttpClient := raflaamoRestaurantsApi.httpClient\r\n\trequest := raflaamoRestaurantsApi.request\r\n\r\n\traflaamoRestaurantsApi.currentTime = currentTime\r\n\r\n\tres, err := httpClient.Do(request)\r\n\r\n\tif err != nil {\r\n\t\tlog.Fatal(\"[GetRestaurantsFromRaflaamoApi]\", errors.New(\"there was an error connecting to the raflaamo api\"))\r\n\t}\r\n\r\n\traflaamoRestaurantsApi.response = res\r\n\r\n\tdecodedRaflaamoRestaurants, err := raflaamoRestaurantsApi.deserializeRaflaamoRestaurantsResponse()\r\n\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"[GetRestaurantsFromRaflaamoApi] - %w\", errors.New(\"there was an error deserializing raflaamo API response\"))\r\n\t}\r\n\r\n\tvalidRestaurantsMatchingCriteria := raflaamoRestaurantsApi.filterBadRestaurantsOut(decodedRaflaamoRestaurants)\r\n\r\n\t// TODO: Handle return value being empty in caller.\r\n\treturn validRestaurantsMatchingCriteria, nil\r\n}\r\n\r\n// A restaurant is considered \"Bad\" if:\r\n//   - Restaurants city is not from the provided city.\r\n//   - Restaurants reservation link does not exist or contains odd contents.\r\n//   - Restaurant does not contain opening times (Specified in the Ranges array).\r\n//   - Restaurant or restaurants kitchen is already closed.\r\nfunc (raflaamoRestaurantsApi *RaflaamoRestaurantsApi) filterBadRestaurantsOut(structureContainingRestaurantData *responseTopLevel) []ResponseFields {\r\n\traflaamoRestaurantsApi.cityToGetRestaurantsFrom = strings.ToLower(raflaamoRestaurantsApi.cityToGetRestaurantsFrom)\r\n\tarrayContainingRestaurantData := structureContainingRestaurantData.Data.ListRestaurantsByLocation.Edges\r\n\r\n\tfilteredRestaurantsFromProvidedCity := make([]ResponseFields, 0, 40)\r\n\tfor _, restaurant := range arrayContainingRestaurantData {\r\n\t\tif restaurant.isBad(raflaamoRestaurantsApi.cityToGetRestaurantsFrom, raflaamoRestaurantsApi.currentTime) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\trestaurant.GraphApiResults = &GraphApiResult{AvailableTimeSlotsBuffer: make(chan string, 96), Err: make(chan error, 96)}\r\n\t\t// Here we have done all the checks we know to date. There might be more in the future once I figure them out.\r\n\t\tfilteredRestaurantsFromProvidedCity = append(filteredRestaurantsFromProvidedCity, restaurant)\r\n\t}\r\n\treturn filteredRestaurantsFromProvidedCity\r\n}\r\n\r\nfunc (response *ResponseFields) isBad(city string, currentTime int64) bool {\r\n\tif response.cityDoesNotMatchUsersCity(city) {\r\n\t\treturn true\r\n\t}\r\n\tif response.reservationLinkIsNotValid() {\r\n\t\treturn true\r\n\t}\r\n\tif response.doesNotContainOpeningTimes() {\r\n\t\treturn true\r\n\t}\r\n\tif response.restaurantOrKitchenIsAlreadyClosed(currentTime) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (response *ResponseFields) doesNotContainOpeningTimes() bool {\r\n\trestaurantsOpeningTimes := response.Openingtime.Restauranttime.Ranges\r\n\tkitchensOpeningTimes := response.Openingtime.Kitchentime.Ranges\r\n\r\n\tif restaurantsOpeningTimes == nil || kitchensOpeningTimes == nil {\r\n\t\treturn true\r\n\t}\r\n\tif restaurantsOpeningTimes[0].Start == \"\" || restaurantsOpeningTimes[0].End == \"\" {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (response *ResponseFields) restaurantOrKitchenIsAlreadyClosed(currentTime int64) bool {\r\n\trestaurantsClosingTime := unixHelpers.ConvertStringTimeToDesiredUnixFormat(response.Openingtime.Restauranttime.Ranges[0].End)\r\n\tkitchenClosingTime := unixHelpers.ConvertStringTimeToDesiredUnixFormat(response.Openingtime.Kitchentime.Ranges[0].End)\r\n\r\n\tif currentTime > restaurantsClosingTime || currentTime > kitchenClosingTime {\r\n\t\treturn true\r\n\t}\r\n\r\n\treturn false\r\n}\r\n\r\nfunc (response *ResponseFields) reservationLinkIsNotValid() bool {\r\n\treturn !strings.Contains(response.Links.TableReservationLocalized.FiFi, \"https://s-varaukset.fi/online/reservation/fi/\")\r\n}\r\n\r\nfunc (response *ResponseFields) cityDoesNotMatchUsersCity(usersCity string) bool {\r\n\tresponse.Address.Municipality.FiFi = strings.ToLower(response.Address.Municipality.FiFi)\r\n\trestaurantsCity := response.Address.Municipality.FiFi\r\n\r\n\treturn restaurantsCity != usersCity\r\n}\r\n\r\nfunc (raflaamoRestaurantsApi *RaflaamoRestaurantsApi) GetAllRestaurantsFromRaflaamoRestaurantsApi(currentTime int64) ([]ResponseFields, error) {\r\n\trestaurantsApi := GetRaflaamoRestaurantsApi(raflaamoRestaurantsApi.cityToGetRestaurantsFrom)\r\n\r\n\trestaurantsFromApi, err := restaurantsApi.getRestaurantsFromRaflaamoApi(currentTime)\r\n\tif err != nil {\r\n\t\tlog.Fatalln(\"can't get restaurants from raflaamo api, cant proceed\")\r\n\t}\r\n\r\n\treturn restaurantsFromApi, nil\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/raflaamoRestaurantsApi/restaurantsApi.go b/raflaamoRestaurantsApi/restaurantsApi.go
--- a/raflaamoRestaurantsApi/restaurantsApi.go	(revision 30c1ba73302c9f79fd18eb7ed5fb2a1ffecb43de)
+++ b/raflaamoRestaurantsApi/restaurantsApi.go	(date 1665385567911)
@@ -75,7 +75,7 @@
 			continue
 		}
 
-		restaurant.GraphApiResults = &GraphApiResult{AvailableTimeSlotsBuffer: make(chan string, 96), Err: make(chan error, 96)}
+		restaurant.GraphApiResults = &GraphApiResult{AvailableTimeSlotsBuffer: make(chan string, 4), Err: make(chan error, 4)}
 		// Here we have done all the checks we know to date. There might be more in the future once I figure them out.
 		filteredRestaurantsFromProvidedCity = append(filteredRestaurantsFromProvidedCity, restaurant)
 	}
